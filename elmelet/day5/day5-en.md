# Day 5 – SQL Fundamentals and Relational Data Modeling

## Key Terms
- **Relational model** – Tables, rows, columns, primary and foreign keys.
- **Normalization** – 1NF, 2NF, 3NF, Boyce–Codd NF; when denormalization is justified.
- **Core SQL operations** – `SELECT`, `INSERT`, `UPDATE`, `DELETE`, `WHERE`, `ORDER BY`, `GROUP BY`.
- **Joins** – `INNER`, `LEFT`, `RIGHT`, `FULL`, `CROSS`, natural joins.
- **Aggregation** – `COUNT`, `SUM`, `AVG`, `MIN`, `MAX`, `HAVING` clause.
- **Transactions** – ACID properties, autocommit vs manual transaction management.
- **Indexes** – Purpose, B-tree concept, composite indexes, trade-offs.
- **Views vs materialized views** – Use cases and differences.

## Interview Questions
1. Explain the difference between an INNER JOIN and a LEFT JOIN. Provide a practical example.

	**Notes:**

2. Describe the ACID properties of transactions.

	**Notes:**

3. What is normalization? When might you intentionally denormalize a schema?

	**Notes:**

4. How do `GROUP BY` and `HAVING` work, and how do they differ?

	**Notes:**

5. What is a composite index and what are its potential downsides?

	**Notes:**

6. Contrast views with materialized views.

	**Notes:**

7. How would you model and query a many-to-many relationship between two tables?

	**Notes:**

## Extra Notes / Practice Ideas
- Write a query that returns the top 3 orders by value for each customer.
- Practice modeling a many-to-many relationship (e.g., `students` and `courses`) and querying it with joins.
- Prepare a junior-friendly explanation of why indexes matter for frequently read tables.
